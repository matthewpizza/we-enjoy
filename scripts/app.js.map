{"version":3,"sources":["webpack:///app.js","webpack:///webpack/bootstrap d8c32f42fd634b4c1966","webpack:///external \"jquery\"","webpack:///./scripts/main.js","webpack:///./scripts/modules/router.js","webpack:///./scripts/vendor/jquery.pjax.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","require","$","document","on","event","pjax","click","container","fragment","jQuery","fnPjax","selector","options","optionsFor","this","opts","extend","attr","handleClick","link","currentTarget","$link","tagName","toUpperCase","which","metaKey","ctrlKey","shiftKey","altKey","location","protocol","hostname","href","indexOf","stripHash","isDefaultPrevented","defaults","url","target","clickEvent","Event","trigger","preventDefault","handleSubmit","form","$form","type","undefined","window","FormData","data","processData","contentType","find","length","serializeArray","fire","args","props","relatedTarget","context","ajaxSettings","isFunction","hash","parseURL","containerType","isArray","push","name","value","_pjax","timeoutTimer","beforeSend","xhr","settings","timeout","setRequestHeader","setTimeout","abort","requestUrl","stripInternalParams","complete","textStatus","clearTimeout","error","errorThrown","extractContainer","allowed","locationReplace","success","status","previousState","state","currentVersion","version","latestVersion","getResponseHeader","contents","uniqueId","title","replace","history","replaceState","blurFocus","contains","activeElement","blur","e","html","autofocusEl","last","focus","executeScriptTags","scripts","scrollTo","decodeURIComponent","slice","getElementById","getElementsByName","offset","top","scrollTop","abortXHR","ajax","readyState","cachePush","cloneContents","pushState","pjaxReload","onPjaxPopstate","initialPop","direction","initialURL","cache","cacheMapping","containerSelector","cachePop","popstateEvent","beforeReplaceEvent","offsetHeight","fallbackPjax","method","action","style","append","toLowerCase","each","split","index","pair","key","body","submit","onreadystatechange","noop","Date","getTime","cloned","clone","src","_data","search","a","createElement","isPlainObject","findAll","elems","filter","add","parseHTML","obj","fullDocument","test","serverUrl","$head","$body","match","head","text","$fragment","first","not","is","remove","trim","existingScripts","matchedScripts","script","appendChild","cacheBackStack","trimCacheStack","cacheForwardStack","maxCacheLength","pushStack","popStack","pop","stack","shift","findVersion","enable","fn","disable","reload","dataType","off","initialState","inArray","prototype","addProp","support","navigator","userAgent"],"mappings":"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","file":"app.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = require(\"jquery\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(3)\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $ = __webpack_require__(1)\n\t__webpack_require__(4)\n\t\n\t$(document).on('click', 'a:not([data-exclude])', function (event) {\n\t  $.pjax.click(event, {\n\t    container: 'main',\n\t    fragment : 'main'\n\t  })\n\t})\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(jQuery) {/*!\n\t * Copyright 2012, Chris Wanstrath\n\t * Released under the MIT License\n\t * https://github.com/defunkt/jquery-pjax\n\t */\n\t\n\t(function($){\n\t\n\t// When called on a container with a selector, fetches the href with\n\t// ajax into the container or with the data-pjax attribute on the link\n\t// itself.\n\t//\n\t// Tries to make sure the back button and ctrl+click work the way\n\t// you'd expect.\n\t//\n\t// Exported as $.fn.pjax\n\t//\n\t// Accepts a jQuery ajax options object that may include these\n\t// pjax specific options:\n\t//\n\t//\n\t// container - String selector for the element where to place the response body.\n\t//      push - Whether to pushState the URL. Defaults to true (of course).\n\t//   replace - Want to use replaceState instead? That's cool.\n\t//\n\t// For convenience the second parameter can be either the container or\n\t// the options object.\n\t//\n\t// Returns the jQuery object\n\tfunction fnPjax(selector, container, options) {\n\t  options = optionsFor(container, options)\n\t  return this.on('click.pjax', selector, function(event) {\n\t    var opts = options\n\t    if (!opts.container) {\n\t      opts = $.extend({}, options)\n\t      opts.container = $(this).attr('data-pjax')\n\t    }\n\t    handleClick(event, opts)\n\t  })\n\t}\n\t\n\t// Public: pjax on click handler\n\t//\n\t// Exported as $.pjax.click.\n\t//\n\t// event   - \"click\" jQuery.Event\n\t// options - pjax options\n\t//\n\t// Examples\n\t//\n\t//   $(document).on('click', 'a', $.pjax.click)\n\t//   // is the same as\n\t//   $(document).pjax('a')\n\t//\n\t// Returns nothing.\n\tfunction handleClick(event, container, options) {\n\t  options = optionsFor(container, options)\n\t\n\t  var link = event.currentTarget\n\t  var $link = $(link)\n\t\n\t  if (link.tagName.toUpperCase() !== 'A')\n\t    throw \"$.fn.pjax or $.pjax.click requires an anchor element\"\n\t\n\t  // Middle click, cmd click, and ctrl click should open\n\t  // links in a new tab as normal.\n\t  if ( event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey )\n\t    return\n\t\n\t  // Ignore cross origin links\n\t  if ( location.protocol !== link.protocol || location.hostname !== link.hostname )\n\t    return\n\t\n\t  // Ignore case when a hash is being tacked on the current URL\n\t  if ( link.href.indexOf('#') > -1 && stripHash(link) == stripHash(location) )\n\t    return\n\t\n\t  // Ignore event with default prevented\n\t  if (event.isDefaultPrevented())\n\t    return\n\t\n\t  var defaults = {\n\t    url: link.href,\n\t    container: $link.attr('data-pjax'),\n\t    target: link\n\t  }\n\t\n\t  var opts = $.extend({}, defaults, options)\n\t  var clickEvent = $.Event('pjax:click')\n\t  $link.trigger(clickEvent, [opts])\n\t\n\t  if (!clickEvent.isDefaultPrevented()) {\n\t    pjax(opts)\n\t    event.preventDefault()\n\t    $link.trigger('pjax:clicked', [opts])\n\t  }\n\t}\n\t\n\t// Public: pjax on form submit handler\n\t//\n\t// Exported as $.pjax.submit\n\t//\n\t// event   - \"click\" jQuery.Event\n\t// options - pjax options\n\t//\n\t// Examples\n\t//\n\t//  $(document).on('submit', 'form', function(event) {\n\t//    $.pjax.submit(event, '[data-pjax-container]')\n\t//  })\n\t//\n\t// Returns nothing.\n\tfunction handleSubmit(event, container, options) {\n\t  options = optionsFor(container, options)\n\t\n\t  var form = event.currentTarget\n\t  var $form = $(form)\n\t\n\t  if (form.tagName.toUpperCase() !== 'FORM')\n\t    throw \"$.pjax.submit requires a form element\"\n\t\n\t  var defaults = {\n\t    type: ($form.attr('method') || 'GET').toUpperCase(),\n\t    url: $form.attr('action'),\n\t    container: $form.attr('data-pjax'),\n\t    target: form\n\t  }\n\t\n\t  if (defaults.type !== 'GET' && window.FormData !== undefined) {\n\t    defaults.data = new FormData(form)\n\t    defaults.processData = false\n\t    defaults.contentType = false\n\t  } else {\n\t    // Can't handle file uploads, exit\n\t    if ($form.find(':file').length) {\n\t      return\n\t    }\n\t\n\t    // Fallback to manually serializing the fields\n\t    defaults.data = $form.serializeArray()\n\t  }\n\t\n\t  pjax($.extend({}, defaults, options))\n\t\n\t  event.preventDefault()\n\t}\n\t\n\t// Loads a URL with ajax, puts the response body inside a container,\n\t// then pushState()'s the loaded URL.\n\t//\n\t// Works just like $.ajax in that it accepts a jQuery ajax\n\t// settings object (with keys like url, type, data, etc).\n\t//\n\t// Accepts these extra keys:\n\t//\n\t// container - String selector for where to stick the response body.\n\t//      push - Whether to pushState the URL. Defaults to true (of course).\n\t//   replace - Want to use replaceState instead? That's cool.\n\t//\n\t// Use it just like $.ajax:\n\t//\n\t//   var xhr = $.pjax({ url: this.href, container: '#main' })\n\t//   console.log( xhr.readyState )\n\t//\n\t// Returns whatever $.ajax returns.\n\tfunction pjax(options) {\n\t  options = $.extend(true, {}, $.ajaxSettings, pjax.defaults, options)\n\t\n\t  if ($.isFunction(options.url)) {\n\t    options.url = options.url()\n\t  }\n\t\n\t  var hash = parseURL(options.url).hash\n\t\n\t  var containerType = $.type(options.container)\n\t  if (containerType !== 'string') {\n\t    throw \"expected string value for 'container' option; got \" + containerType\n\t  }\n\t  var context = options.context = $(options.container)\n\t  if (!context.length) {\n\t    throw \"the container selector '\" + options.container + \"' did not match anything\"\n\t  }\n\t\n\t  // We want the browser to maintain two separate internal caches: one\n\t  // for pjax'd partial page loads and one for normal page loads.\n\t  // Without adding this secret parameter, some browsers will often\n\t  // confuse the two.\n\t  if (!options.data) options.data = {}\n\t  if ($.isArray(options.data)) {\n\t    options.data.push({name: '_pjax', value: options.container})\n\t  } else {\n\t    options.data._pjax = options.container\n\t  }\n\t\n\t  function fire(type, args, props) {\n\t    if (!props) props = {}\n\t    props.relatedTarget = options.target\n\t    var event = $.Event(type, props)\n\t    context.trigger(event, args)\n\t    return !event.isDefaultPrevented()\n\t  }\n\t\n\t  var timeoutTimer\n\t\n\t  options.beforeSend = function(xhr, settings) {\n\t    // No timeout for non-GET requests\n\t    // Its not safe to request the resource again with a fallback method.\n\t    if (settings.type !== 'GET') {\n\t      settings.timeout = 0\n\t    }\n\t\n\t    xhr.setRequestHeader('X-PJAX', 'true')\n\t    xhr.setRequestHeader('X-PJAX-Container', options.container)\n\t\n\t    if (!fire('pjax:beforeSend', [xhr, settings]))\n\t      return false\n\t\n\t    if (settings.timeout > 0) {\n\t      timeoutTimer = setTimeout(function() {\n\t        if (fire('pjax:timeout', [xhr, options]))\n\t          xhr.abort('timeout')\n\t      }, settings.timeout)\n\t\n\t      // Clear timeout setting so jquerys internal timeout isn't invoked\n\t      settings.timeout = 0\n\t    }\n\t\n\t    var url = parseURL(settings.url)\n\t    if (hash) url.hash = hash\n\t    options.requestUrl = stripInternalParams(url)\n\t  }\n\t\n\t  options.complete = function(xhr, textStatus) {\n\t    if (timeoutTimer)\n\t      clearTimeout(timeoutTimer)\n\t\n\t    fire('pjax:complete', [xhr, textStatus, options])\n\t\n\t    fire('pjax:end', [xhr, options])\n\t  }\n\t\n\t  options.error = function(xhr, textStatus, errorThrown) {\n\t    var container = extractContainer(\"\", xhr, options)\n\t\n\t    var allowed = fire('pjax:error', [xhr, textStatus, errorThrown, options])\n\t    if (options.type == 'GET' && textStatus !== 'abort' && allowed) {\n\t      locationReplace(container.url)\n\t    }\n\t  }\n\t\n\t  options.success = function(data, status, xhr) {\n\t    var previousState = pjax.state\n\t\n\t    // If $.pjax.defaults.version is a function, invoke it first.\n\t    // Otherwise it can be a static string.\n\t    var currentVersion = typeof $.pjax.defaults.version === 'function' ?\n\t      $.pjax.defaults.version() :\n\t      $.pjax.defaults.version\n\t\n\t    var latestVersion = xhr.getResponseHeader('X-PJAX-Version')\n\t\n\t    var container = extractContainer(data, xhr, options)\n\t\n\t    var url = parseURL(container.url)\n\t    if (hash) {\n\t      url.hash = hash\n\t      container.url = url.href\n\t    }\n\t\n\t    // If there is a layout version mismatch, hard load the new url\n\t    if (currentVersion && latestVersion && currentVersion !== latestVersion) {\n\t      locationReplace(container.url)\n\t      return\n\t    }\n\t\n\t    // If the new response is missing a body, hard load the page\n\t    if (!container.contents) {\n\t      locationReplace(container.url)\n\t      return\n\t    }\n\t\n\t    pjax.state = {\n\t      id: options.id || uniqueId(),\n\t      url: container.url,\n\t      title: container.title,\n\t      container: options.container,\n\t      fragment: options.fragment,\n\t      timeout: options.timeout\n\t    }\n\t\n\t    if (options.push || options.replace) {\n\t      window.history.replaceState(pjax.state, container.title, container.url)\n\t    }\n\t\n\t    // Only blur the focus if the focused element is within the container.\n\t    var blurFocus = $.contains(context, document.activeElement)\n\t\n\t    // Clear out any focused controls before inserting new page contents.\n\t    if (blurFocus) {\n\t      try {\n\t        document.activeElement.blur()\n\t      } catch (e) { /* ignore */ }\n\t    }\n\t\n\t    if (container.title) document.title = container.title\n\t\n\t    fire('pjax:beforeReplace', [container.contents, options], {\n\t      state: pjax.state,\n\t      previousState: previousState\n\t    })\n\t    context.html(container.contents)\n\t\n\t    // FF bug: Won't autofocus fields that are inserted via JS.\n\t    // This behavior is incorrect. So if theres no current focus, autofocus\n\t    // the last field.\n\t    //\n\t    // http://www.w3.org/html/wg/drafts/html/master/forms.html\n\t    var autofocusEl = context.find('input[autofocus], textarea[autofocus]').last()[0]\n\t    if (autofocusEl && document.activeElement !== autofocusEl) {\n\t      autofocusEl.focus()\n\t    }\n\t\n\t    executeScriptTags(container.scripts)\n\t\n\t    var scrollTo = options.scrollTo\n\t\n\t    // Ensure browser scrolls to the element referenced by the URL anchor\n\t    if (hash) {\n\t      var name = decodeURIComponent(hash.slice(1))\n\t      var target = document.getElementById(name) || document.getElementsByName(name)[0]\n\t      if (target) scrollTo = $(target).offset().top\n\t    }\n\t\n\t    if (typeof scrollTo == 'number') $(window).scrollTop(scrollTo)\n\t\n\t    fire('pjax:success', [data, status, xhr, options])\n\t  }\n\t\n\t\n\t  // Initialize pjax.state for the initial page load. Assume we're\n\t  // using the container and options of the link we're loading for the\n\t  // back button to the initial page. This ensures good back button\n\t  // behavior.\n\t  if (!pjax.state) {\n\t    pjax.state = {\n\t      id: uniqueId(),\n\t      url: window.location.href,\n\t      title: document.title,\n\t      container: options.container,\n\t      fragment: options.fragment,\n\t      timeout: options.timeout\n\t    }\n\t    window.history.replaceState(pjax.state, document.title)\n\t  }\n\t\n\t  // Cancel the current request if we're already pjaxing\n\t  abortXHR(pjax.xhr)\n\t\n\t  pjax.options = options\n\t  var xhr = pjax.xhr = $.ajax(options)\n\t\n\t  if (xhr.readyState > 0) {\n\t    if (options.push && !options.replace) {\n\t      // Cache current container element before replacing it\n\t      cachePush(pjax.state.id, [options.container, cloneContents(context)])\n\t\n\t      window.history.pushState(null, \"\", options.requestUrl)\n\t    }\n\t\n\t    fire('pjax:start', [xhr, options])\n\t    fire('pjax:send', [xhr, options])\n\t  }\n\t\n\t  return pjax.xhr\n\t}\n\t\n\t// Public: Reload current page with pjax.\n\t//\n\t// Returns whatever $.pjax returns.\n\tfunction pjaxReload(container, options) {\n\t  var defaults = {\n\t    url: window.location.href,\n\t    push: false,\n\t    replace: true,\n\t    scrollTo: false\n\t  }\n\t\n\t  return pjax($.extend(defaults, optionsFor(container, options)))\n\t}\n\t\n\t// Internal: Hard replace current state with url.\n\t//\n\t// Work for around WebKit\n\t//   https://bugs.webkit.org/show_bug.cgi?id=93506\n\t//\n\t// Returns nothing.\n\tfunction locationReplace(url) {\n\t  window.history.replaceState(null, \"\", pjax.state.url)\n\t  window.location.replace(url)\n\t}\n\t\n\t\n\tvar initialPop = true\n\tvar initialURL = window.location.href\n\tvar initialState = window.history.state\n\t\n\t// Initialize $.pjax.state if possible\n\t// Happens when reloading a page and coming forward from a different\n\t// session history.\n\tif (initialState && initialState.container) {\n\t  pjax.state = initialState\n\t}\n\t\n\t// Non-webkit browsers don't fire an initial popstate event\n\tif ('state' in window.history) {\n\t  initialPop = false\n\t}\n\t\n\t// popstate handler takes care of the back and forward buttons\n\t//\n\t// You probably shouldn't use pjax on pages with other pushState\n\t// stuff yet.\n\tfunction onPjaxPopstate(event) {\n\t\n\t  // Hitting back or forward should override any pending PJAX request.\n\t  if (!initialPop) {\n\t    abortXHR(pjax.xhr)\n\t  }\n\t\n\t  var previousState = pjax.state\n\t  var state = event.state\n\t  var direction\n\t\n\t  if (state && state.container) {\n\t    // When coming forward from a separate history session, will get an\n\t    // initial pop with a state we are already at. Skip reloading the current\n\t    // page.\n\t    if (initialPop && initialURL == state.url) return\n\t\n\t    if (previousState) {\n\t      // If popping back to the same state, just skip.\n\t      // Could be clicking back from hashchange rather than a pushState.\n\t      if (previousState.id === state.id) return\n\t\n\t      // Since state IDs always increase, we can deduce the navigation direction\n\t      direction = previousState.id < state.id ? 'forward' : 'back'\n\t    }\n\t\n\t    var cache = cacheMapping[state.id] || []\n\t    var containerSelector = cache[0] || state.container\n\t    var container = $(containerSelector), contents = cache[1]\n\t\n\t    if (container.length) {\n\t      if (previousState) {\n\t        // Cache current container before replacement and inform the\n\t        // cache which direction the history shifted.\n\t        cachePop(direction, previousState.id, [containerSelector, cloneContents(container)])\n\t      }\n\t\n\t      var popstateEvent = $.Event('pjax:popstate', {\n\t        state: state,\n\t        direction: direction\n\t      })\n\t      container.trigger(popstateEvent)\n\t\n\t      var options = {\n\t        id: state.id,\n\t        url: state.url,\n\t        container: containerSelector,\n\t        push: false,\n\t        fragment: state.fragment,\n\t        timeout: state.timeout,\n\t        scrollTo: false\n\t      }\n\t\n\t      if (contents) {\n\t        container.trigger('pjax:start', [null, options])\n\t\n\t        pjax.state = state\n\t        if (state.title) document.title = state.title\n\t        var beforeReplaceEvent = $.Event('pjax:beforeReplace', {\n\t          state: state,\n\t          previousState: previousState\n\t        })\n\t        container.trigger(beforeReplaceEvent, [contents, options])\n\t        container.html(contents)\n\t\n\t        container.trigger('pjax:end', [null, options])\n\t      } else {\n\t        pjax(options)\n\t      }\n\t\n\t      // Force reflow/relayout before the browser tries to restore the\n\t      // scroll position.\n\t      container[0].offsetHeight // eslint-disable-line no-unused-expressions\n\t    } else {\n\t      locationReplace(location.href)\n\t    }\n\t  }\n\t  initialPop = false\n\t}\n\t\n\t// Fallback version of main pjax function for browsers that don't\n\t// support pushState.\n\t//\n\t// Returns nothing since it retriggers a hard form submission.\n\tfunction fallbackPjax(options) {\n\t  var url = $.isFunction(options.url) ? options.url() : options.url,\n\t      method = options.type ? options.type.toUpperCase() : 'GET'\n\t\n\t  var form = $('<form>', {\n\t    method: method === 'GET' ? 'GET' : 'POST',\n\t    action: url,\n\t    style: 'display:none'\n\t  })\n\t\n\t  if (method !== 'GET' && method !== 'POST') {\n\t    form.append($('<input>', {\n\t      type: 'hidden',\n\t      name: '_method',\n\t      value: method.toLowerCase()\n\t    }))\n\t  }\n\t\n\t  var data = options.data\n\t  if (typeof data === 'string') {\n\t    $.each(data.split('&'), function(index, value) {\n\t      var pair = value.split('=')\n\t      form.append($('<input>', {type: 'hidden', name: pair[0], value: pair[1]}))\n\t    })\n\t  } else if ($.isArray(data)) {\n\t    $.each(data, function(index, value) {\n\t      form.append($('<input>', {type: 'hidden', name: value.name, value: value.value}))\n\t    })\n\t  } else if (typeof data === 'object') {\n\t    var key\n\t    for (key in data)\n\t      form.append($('<input>', {type: 'hidden', name: key, value: data[key]}))\n\t  }\n\t\n\t  $(document.body).append(form)\n\t  form.submit()\n\t}\n\t\n\t// Internal: Abort an XmlHttpRequest if it hasn't been completed,\n\t// also removing its event handlers.\n\tfunction abortXHR(xhr) {\n\t  if ( xhr && xhr.readyState < 4) {\n\t    xhr.onreadystatechange = $.noop\n\t    xhr.abort()\n\t  }\n\t}\n\t\n\t// Internal: Generate unique id for state object.\n\t//\n\t// Use a timestamp instead of a counter since ids should still be\n\t// unique across page loads.\n\t//\n\t// Returns Number.\n\tfunction uniqueId() {\n\t  return (new Date).getTime()\n\t}\n\t\n\tfunction cloneContents(container) {\n\t  var cloned = container.clone()\n\t  // Unmark script tags as already being eval'd so they can get executed again\n\t  // when restored from cache. HAXX: Uses jQuery internal method.\n\t  cloned.find('script').each(function(){\n\t    if (!this.src) $._data(this, 'globalEval', false)\n\t  })\n\t  return cloned.contents()\n\t}\n\t\n\t// Internal: Strip internal query params from parsed URL.\n\t//\n\t// Returns sanitized url.href String.\n\tfunction stripInternalParams(url) {\n\t  url.search = url.search.replace(/([?&])(_pjax|_)=[^&]*/g, '').replace(/^&/, '')\n\t  return url.href.replace(/\\?($|#)/, '$1')\n\t}\n\t\n\t// Internal: Parse URL components and returns a Locationish object.\n\t//\n\t// url - String URL\n\t//\n\t// Returns HTMLAnchorElement that acts like Location.\n\tfunction parseURL(url) {\n\t  var a = document.createElement('a')\n\t  a.href = url\n\t  return a\n\t}\n\t\n\t// Internal: Return the `href` component of given URL object with the hash\n\t// portion removed.\n\t//\n\t// location - Location or HTMLAnchorElement\n\t//\n\t// Returns String\n\tfunction stripHash(location) {\n\t  return location.href.replace(/#.*/, '')\n\t}\n\t\n\t// Internal: Build options Object for arguments.\n\t//\n\t// For convenience the first parameter can be either the container or\n\t// the options object.\n\t//\n\t// Examples\n\t//\n\t//   optionsFor('#container')\n\t//   // => {container: '#container'}\n\t//\n\t//   optionsFor('#container', {push: true})\n\t//   // => {container: '#container', push: true}\n\t//\n\t//   optionsFor({container: '#container', push: true})\n\t//   // => {container: '#container', push: true}\n\t//\n\t// Returns options Object.\n\tfunction optionsFor(container, options) {\n\t  if (container && options) {\n\t    options = $.extend({}, options)\n\t    options.container = container\n\t    return options\n\t  } else if ($.isPlainObject(container)) {\n\t    return container\n\t  } else {\n\t    return {container: container}\n\t  }\n\t}\n\t\n\t// Internal: Filter and find all elements matching the selector.\n\t//\n\t// Where $.fn.find only matches descendants, findAll will test all the\n\t// top level elements in the jQuery object as well.\n\t//\n\t// elems    - jQuery object of Elements\n\t// selector - String selector to match\n\t//\n\t// Returns a jQuery object.\n\tfunction findAll(elems, selector) {\n\t  return elems.filter(selector).add(elems.find(selector))\n\t}\n\t\n\tfunction parseHTML(html) {\n\t  return $.parseHTML(html, document, true)\n\t}\n\t\n\t// Internal: Extracts container and metadata from response.\n\t//\n\t// 1. Extracts X-PJAX-URL header if set\n\t// 2. Extracts inline <title> tags\n\t// 3. Builds response Element and extracts fragment if set\n\t//\n\t// data    - String response data\n\t// xhr     - XHR response\n\t// options - pjax options Object\n\t//\n\t// Returns an Object with url, title, and contents keys.\n\tfunction extractContainer(data, xhr, options) {\n\t  var obj = {}, fullDocument = /<html/i.test(data)\n\t\n\t  // Prefer X-PJAX-URL header if it was set, otherwise fallback to\n\t  // using the original requested url.\n\t  var serverUrl = xhr.getResponseHeader('X-PJAX-URL')\n\t  obj.url = serverUrl ? stripInternalParams(parseURL(serverUrl)) : options.requestUrl\n\t\n\t  var $head, $body\n\t  // Attempt to parse response html into elements\n\t  if (fullDocument) {\n\t    $body = $(parseHTML(data.match(/<body[^>]*>([\\s\\S.]*)<\\/body>/i)[0]))\n\t    var head = data.match(/<head[^>]*>([\\s\\S.]*)<\\/head>/i)\n\t    $head = head != null ? $(parseHTML(head[0])) : $body\n\t  } else {\n\t    $head = $body = $(parseHTML(data))\n\t  }\n\t\n\t  // If response data is empty, return fast\n\t  if ($body.length === 0)\n\t    return obj\n\t\n\t  // If there's a <title> tag in the header, use it as\n\t  // the page's title.\n\t  obj.title = findAll($head, 'title').last().text()\n\t\n\t  if (options.fragment) {\n\t    var $fragment = $body\n\t    // If they specified a fragment, look for it in the response\n\t    // and pull it out.\n\t    if (options.fragment !== 'body') {\n\t      $fragment = findAll($fragment, options.fragment).first()\n\t    }\n\t\n\t    if ($fragment.length) {\n\t      obj.contents = options.fragment === 'body' ? $fragment : $fragment.contents()\n\t\n\t      // If there's no title, look for data-title and title attributes\n\t      // on the fragment\n\t      if (!obj.title)\n\t        obj.title = $fragment.attr('title') || $fragment.data('title')\n\t    }\n\t\n\t  } else if (!fullDocument) {\n\t    obj.contents = $body\n\t  }\n\t\n\t  // Clean up any <title> tags\n\t  if (obj.contents) {\n\t    // Remove any parent title elements\n\t    obj.contents = obj.contents.not(function() { return $(this).is('title') })\n\t\n\t    // Then scrub any titles from their descendants\n\t    obj.contents.find('title').remove()\n\t\n\t    // Gather all script[src] elements\n\t    obj.scripts = findAll(obj.contents, 'script[src]').remove()\n\t    obj.contents = obj.contents.not(obj.scripts)\n\t  }\n\t\n\t  // Trim any whitespace off the title\n\t  if (obj.title) obj.title = $.trim(obj.title)\n\t\n\t  return obj\n\t}\n\t\n\t// Load an execute scripts using standard script request.\n\t//\n\t// Avoids jQuery's traditional $.getScript which does a XHR request and\n\t// globalEval.\n\t//\n\t// scripts - jQuery object of script Elements\n\t//\n\t// Returns nothing.\n\tfunction executeScriptTags(scripts) {\n\t  if (!scripts) return\n\t\n\t  var existingScripts = $('script[src]')\n\t\n\t  scripts.each(function() {\n\t    var src = this.src\n\t    var matchedScripts = existingScripts.filter(function() {\n\t      return this.src === src\n\t    })\n\t    if (matchedScripts.length) return\n\t\n\t    var script = document.createElement('script')\n\t    var type = $(this).attr('type')\n\t    if (type) script.type = type\n\t    script.src = $(this).attr('src')\n\t    document.head.appendChild(script)\n\t  })\n\t}\n\t\n\t// Internal: History DOM caching class.\n\tvar cacheMapping      = {}\n\tvar cacheForwardStack = []\n\tvar cacheBackStack    = []\n\t\n\t// Push previous state id and container contents into the history\n\t// cache. Should be called in conjunction with `pushState` to save the\n\t// previous container contents.\n\t//\n\t// id    - State ID Number\n\t// value - DOM Element to cache\n\t//\n\t// Returns nothing.\n\tfunction cachePush(id, value) {\n\t  cacheMapping[id] = value\n\t  cacheBackStack.push(id)\n\t\n\t  // Remove all entries in forward history stack after pushing a new page.\n\t  trimCacheStack(cacheForwardStack, 0)\n\t\n\t  // Trim back history stack to max cache length.\n\t  trimCacheStack(cacheBackStack, pjax.defaults.maxCacheLength)\n\t}\n\t\n\t// Shifts cache from directional history cache. Should be\n\t// called on `popstate` with the previous state id and container\n\t// contents.\n\t//\n\t// direction - \"forward\" or \"back\" String\n\t// id        - State ID Number\n\t// value     - DOM Element to cache\n\t//\n\t// Returns nothing.\n\tfunction cachePop(direction, id, value) {\n\t  var pushStack, popStack\n\t  cacheMapping[id] = value\n\t\n\t  if (direction === 'forward') {\n\t    pushStack = cacheBackStack\n\t    popStack  = cacheForwardStack\n\t  } else {\n\t    pushStack = cacheForwardStack\n\t    popStack  = cacheBackStack\n\t  }\n\t\n\t  pushStack.push(id)\n\t  id = popStack.pop()\n\t  if (id) delete cacheMapping[id]\n\t\n\t  // Trim whichever stack we just pushed to to max cache length.\n\t  trimCacheStack(pushStack, pjax.defaults.maxCacheLength)\n\t}\n\t\n\t// Trim a cache stack (either cacheBackStack or cacheForwardStack) to be no\n\t// longer than the specified length, deleting cached DOM elements as necessary.\n\t//\n\t// stack  - Array of state IDs\n\t// length - Maximum length to trim to\n\t//\n\t// Returns nothing.\n\tfunction trimCacheStack(stack, length) {\n\t  while (stack.length > length)\n\t    delete cacheMapping[stack.shift()]\n\t}\n\t\n\t// Public: Find version identifier for the initial page load.\n\t//\n\t// Returns String version or undefined.\n\tfunction findVersion() {\n\t  return $('meta').filter(function() {\n\t    var name = $(this).attr('http-equiv')\n\t    return name && name.toUpperCase() === 'X-PJAX-VERSION'\n\t  }).attr('content')\n\t}\n\t\n\t// Install pjax functions on $.pjax to enable pushState behavior.\n\t//\n\t// Does nothing if already enabled.\n\t//\n\t// Examples\n\t//\n\t//     $.pjax.enable()\n\t//\n\t// Returns nothing.\n\tfunction enable() {\n\t  $.fn.pjax = fnPjax\n\t  $.pjax = pjax\n\t  $.pjax.enable = $.noop\n\t  $.pjax.disable = disable\n\t  $.pjax.click = handleClick\n\t  $.pjax.submit = handleSubmit\n\t  $.pjax.reload = pjaxReload\n\t  $.pjax.defaults = {\n\t    timeout: 650,\n\t    push: true,\n\t    replace: false,\n\t    type: 'GET',\n\t    dataType: 'html',\n\t    scrollTo: 0,\n\t    maxCacheLength: 20,\n\t    version: findVersion\n\t  }\n\t  $(window).on('popstate.pjax', onPjaxPopstate)\n\t}\n\t\n\t// Disable pushState behavior.\n\t//\n\t// This is the case when a browser doesn't support pushState. It is\n\t// sometimes useful to disable pushState for debugging on a modern\n\t// browser.\n\t//\n\t// Examples\n\t//\n\t//     $.pjax.disable()\n\t//\n\t// Returns nothing.\n\tfunction disable() {\n\t  $.fn.pjax = function() { return this }\n\t  $.pjax = fallbackPjax\n\t  $.pjax.enable = enable\n\t  $.pjax.disable = $.noop\n\t  $.pjax.click = $.noop\n\t  $.pjax.submit = $.noop\n\t  $.pjax.reload = function() { window.location.reload() }\n\t\n\t  $(window).off('popstate.pjax', onPjaxPopstate)\n\t}\n\t\n\t\n\t// Add the state property to jQuery's event object so we can use it in\n\t// $(window).bind('popstate')\n\tif ($.event.props && $.inArray('state', $.event.props) < 0) {\n\t  $.event.props.push('state')\n\t} else if (!('state' in $.Event.prototype)) {\n\t  $.event.addProp('state')\n\t}\n\t\n\t// Is pjax supported by this browser?\n\t$.support.pjax =\n\t  window.history && window.history.pushState && window.history.replaceState &&\n\t  // pushState isn't reliable on iOS until 5.\n\t  !navigator.userAgent.match(/((iPod|iPhone|iPad).+\\bOS\\s+[1-4]\\D|WebApps\\/.+CFNetwork)/)\n\t\n\tif ($.support.pjax) {\n\t  enable()\n\t} else {\n\t  disable()\n\t}\n\t\n\t})(jQuery)\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** app.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d8c32f42fd634b4c1966\n **/","module.exports = require(\"jquery\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"jquery\"\n ** module id = 1\n ** module chunks = 0\n **/","require('modules/router')\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/main.js\n ** module id = 2\n ** module chunks = 0\n **/","var $ = require('jquery')\nrequire('pjax')\n\n$(document).on('click', 'a:not([data-exclude])', function (event) {\n  $.pjax.click(event, {\n    container: 'main',\n    fragment : 'main'\n  })\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/modules/router.js\n ** module id = 3\n ** module chunks = 0\n **/","/*!\n * Copyright 2012, Chris Wanstrath\n * Released under the MIT License\n * https://github.com/defunkt/jquery-pjax\n */\n\n(function($){\n\n// When called on a container with a selector, fetches the href with\n// ajax into the container or with the data-pjax attribute on the link\n// itself.\n//\n// Tries to make sure the back button and ctrl+click work the way\n// you'd expect.\n//\n// Exported as $.fn.pjax\n//\n// Accepts a jQuery ajax options object that may include these\n// pjax specific options:\n//\n//\n// container - String selector for the element where to place the response body.\n//      push - Whether to pushState the URL. Defaults to true (of course).\n//   replace - Want to use replaceState instead? That's cool.\n//\n// For convenience the second parameter can be either the container or\n// the options object.\n//\n// Returns the jQuery object\nfunction fnPjax(selector, container, options) {\n  options = optionsFor(container, options)\n  return this.on('click.pjax', selector, function(event) {\n    var opts = options\n    if (!opts.container) {\n      opts = $.extend({}, options)\n      opts.container = $(this).attr('data-pjax')\n    }\n    handleClick(event, opts)\n  })\n}\n\n// Public: pjax on click handler\n//\n// Exported as $.pjax.click.\n//\n// event   - \"click\" jQuery.Event\n// options - pjax options\n//\n// Examples\n//\n//   $(document).on('click', 'a', $.pjax.click)\n//   // is the same as\n//   $(document).pjax('a')\n//\n// Returns nothing.\nfunction handleClick(event, container, options) {\n  options = optionsFor(container, options)\n\n  var link = event.currentTarget\n  var $link = $(link)\n\n  if (link.tagName.toUpperCase() !== 'A')\n    throw \"$.fn.pjax or $.pjax.click requires an anchor element\"\n\n  // Middle click, cmd click, and ctrl click should open\n  // links in a new tab as normal.\n  if ( event.which > 1 || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey )\n    return\n\n  // Ignore cross origin links\n  if ( location.protocol !== link.protocol || location.hostname !== link.hostname )\n    return\n\n  // Ignore case when a hash is being tacked on the current URL\n  if ( link.href.indexOf('#') > -1 && stripHash(link) == stripHash(location) )\n    return\n\n  // Ignore event with default prevented\n  if (event.isDefaultPrevented())\n    return\n\n  var defaults = {\n    url: link.href,\n    container: $link.attr('data-pjax'),\n    target: link\n  }\n\n  var opts = $.extend({}, defaults, options)\n  var clickEvent = $.Event('pjax:click')\n  $link.trigger(clickEvent, [opts])\n\n  if (!clickEvent.isDefaultPrevented()) {\n    pjax(opts)\n    event.preventDefault()\n    $link.trigger('pjax:clicked', [opts])\n  }\n}\n\n// Public: pjax on form submit handler\n//\n// Exported as $.pjax.submit\n//\n// event   - \"click\" jQuery.Event\n// options - pjax options\n//\n// Examples\n//\n//  $(document).on('submit', 'form', function(event) {\n//    $.pjax.submit(event, '[data-pjax-container]')\n//  })\n//\n// Returns nothing.\nfunction handleSubmit(event, container, options) {\n  options = optionsFor(container, options)\n\n  var form = event.currentTarget\n  var $form = $(form)\n\n  if (form.tagName.toUpperCase() !== 'FORM')\n    throw \"$.pjax.submit requires a form element\"\n\n  var defaults = {\n    type: ($form.attr('method') || 'GET').toUpperCase(),\n    url: $form.attr('action'),\n    container: $form.attr('data-pjax'),\n    target: form\n  }\n\n  if (defaults.type !== 'GET' && window.FormData !== undefined) {\n    defaults.data = new FormData(form)\n    defaults.processData = false\n    defaults.contentType = false\n  } else {\n    // Can't handle file uploads, exit\n    if ($form.find(':file').length) {\n      return\n    }\n\n    // Fallback to manually serializing the fields\n    defaults.data = $form.serializeArray()\n  }\n\n  pjax($.extend({}, defaults, options))\n\n  event.preventDefault()\n}\n\n// Loads a URL with ajax, puts the response body inside a container,\n// then pushState()'s the loaded URL.\n//\n// Works just like $.ajax in that it accepts a jQuery ajax\n// settings object (with keys like url, type, data, etc).\n//\n// Accepts these extra keys:\n//\n// container - String selector for where to stick the response body.\n//      push - Whether to pushState the URL. Defaults to true (of course).\n//   replace - Want to use replaceState instead? That's cool.\n//\n// Use it just like $.ajax:\n//\n//   var xhr = $.pjax({ url: this.href, container: '#main' })\n//   console.log( xhr.readyState )\n//\n// Returns whatever $.ajax returns.\nfunction pjax(options) {\n  options = $.extend(true, {}, $.ajaxSettings, pjax.defaults, options)\n\n  if ($.isFunction(options.url)) {\n    options.url = options.url()\n  }\n\n  var hash = parseURL(options.url).hash\n\n  var containerType = $.type(options.container)\n  if (containerType !== 'string') {\n    throw \"expected string value for 'container' option; got \" + containerType\n  }\n  var context = options.context = $(options.container)\n  if (!context.length) {\n    throw \"the container selector '\" + options.container + \"' did not match anything\"\n  }\n\n  // We want the browser to maintain two separate internal caches: one\n  // for pjax'd partial page loads and one for normal page loads.\n  // Without adding this secret parameter, some browsers will often\n  // confuse the two.\n  if (!options.data) options.data = {}\n  if ($.isArray(options.data)) {\n    options.data.push({name: '_pjax', value: options.container})\n  } else {\n    options.data._pjax = options.container\n  }\n\n  function fire(type, args, props) {\n    if (!props) props = {}\n    props.relatedTarget = options.target\n    var event = $.Event(type, props)\n    context.trigger(event, args)\n    return !event.isDefaultPrevented()\n  }\n\n  var timeoutTimer\n\n  options.beforeSend = function(xhr, settings) {\n    // No timeout for non-GET requests\n    // Its not safe to request the resource again with a fallback method.\n    if (settings.type !== 'GET') {\n      settings.timeout = 0\n    }\n\n    xhr.setRequestHeader('X-PJAX', 'true')\n    xhr.setRequestHeader('X-PJAX-Container', options.container)\n\n    if (!fire('pjax:beforeSend', [xhr, settings]))\n      return false\n\n    if (settings.timeout > 0) {\n      timeoutTimer = setTimeout(function() {\n        if (fire('pjax:timeout', [xhr, options]))\n          xhr.abort('timeout')\n      }, settings.timeout)\n\n      // Clear timeout setting so jquerys internal timeout isn't invoked\n      settings.timeout = 0\n    }\n\n    var url = parseURL(settings.url)\n    if (hash) url.hash = hash\n    options.requestUrl = stripInternalParams(url)\n  }\n\n  options.complete = function(xhr, textStatus) {\n    if (timeoutTimer)\n      clearTimeout(timeoutTimer)\n\n    fire('pjax:complete', [xhr, textStatus, options])\n\n    fire('pjax:end', [xhr, options])\n  }\n\n  options.error = function(xhr, textStatus, errorThrown) {\n    var container = extractContainer(\"\", xhr, options)\n\n    var allowed = fire('pjax:error', [xhr, textStatus, errorThrown, options])\n    if (options.type == 'GET' && textStatus !== 'abort' && allowed) {\n      locationReplace(container.url)\n    }\n  }\n\n  options.success = function(data, status, xhr) {\n    var previousState = pjax.state\n\n    // If $.pjax.defaults.version is a function, invoke it first.\n    // Otherwise it can be a static string.\n    var currentVersion = typeof $.pjax.defaults.version === 'function' ?\n      $.pjax.defaults.version() :\n      $.pjax.defaults.version\n\n    var latestVersion = xhr.getResponseHeader('X-PJAX-Version')\n\n    var container = extractContainer(data, xhr, options)\n\n    var url = parseURL(container.url)\n    if (hash) {\n      url.hash = hash\n      container.url = url.href\n    }\n\n    // If there is a layout version mismatch, hard load the new url\n    if (currentVersion && latestVersion && currentVersion !== latestVersion) {\n      locationReplace(container.url)\n      return\n    }\n\n    // If the new response is missing a body, hard load the page\n    if (!container.contents) {\n      locationReplace(container.url)\n      return\n    }\n\n    pjax.state = {\n      id: options.id || uniqueId(),\n      url: container.url,\n      title: container.title,\n      container: options.container,\n      fragment: options.fragment,\n      timeout: options.timeout\n    }\n\n    if (options.push || options.replace) {\n      window.history.replaceState(pjax.state, container.title, container.url)\n    }\n\n    // Only blur the focus if the focused element is within the container.\n    var blurFocus = $.contains(context, document.activeElement)\n\n    // Clear out any focused controls before inserting new page contents.\n    if (blurFocus) {\n      try {\n        document.activeElement.blur()\n      } catch (e) { /* ignore */ }\n    }\n\n    if (container.title) document.title = container.title\n\n    fire('pjax:beforeReplace', [container.contents, options], {\n      state: pjax.state,\n      previousState: previousState\n    })\n    context.html(container.contents)\n\n    // FF bug: Won't autofocus fields that are inserted via JS.\n    // This behavior is incorrect. So if theres no current focus, autofocus\n    // the last field.\n    //\n    // http://www.w3.org/html/wg/drafts/html/master/forms.html\n    var autofocusEl = context.find('input[autofocus], textarea[autofocus]').last()[0]\n    if (autofocusEl && document.activeElement !== autofocusEl) {\n      autofocusEl.focus()\n    }\n\n    executeScriptTags(container.scripts)\n\n    var scrollTo = options.scrollTo\n\n    // Ensure browser scrolls to the element referenced by the URL anchor\n    if (hash) {\n      var name = decodeURIComponent(hash.slice(1))\n      var target = document.getElementById(name) || document.getElementsByName(name)[0]\n      if (target) scrollTo = $(target).offset().top\n    }\n\n    if (typeof scrollTo == 'number') $(window).scrollTop(scrollTo)\n\n    fire('pjax:success', [data, status, xhr, options])\n  }\n\n\n  // Initialize pjax.state for the initial page load. Assume we're\n  // using the container and options of the link we're loading for the\n  // back button to the initial page. This ensures good back button\n  // behavior.\n  if (!pjax.state) {\n    pjax.state = {\n      id: uniqueId(),\n      url: window.location.href,\n      title: document.title,\n      container: options.container,\n      fragment: options.fragment,\n      timeout: options.timeout\n    }\n    window.history.replaceState(pjax.state, document.title)\n  }\n\n  // Cancel the current request if we're already pjaxing\n  abortXHR(pjax.xhr)\n\n  pjax.options = options\n  var xhr = pjax.xhr = $.ajax(options)\n\n  if (xhr.readyState > 0) {\n    if (options.push && !options.replace) {\n      // Cache current container element before replacing it\n      cachePush(pjax.state.id, [options.container, cloneContents(context)])\n\n      window.history.pushState(null, \"\", options.requestUrl)\n    }\n\n    fire('pjax:start', [xhr, options])\n    fire('pjax:send', [xhr, options])\n  }\n\n  return pjax.xhr\n}\n\n// Public: Reload current page with pjax.\n//\n// Returns whatever $.pjax returns.\nfunction pjaxReload(container, options) {\n  var defaults = {\n    url: window.location.href,\n    push: false,\n    replace: true,\n    scrollTo: false\n  }\n\n  return pjax($.extend(defaults, optionsFor(container, options)))\n}\n\n// Internal: Hard replace current state with url.\n//\n// Work for around WebKit\n//   https://bugs.webkit.org/show_bug.cgi?id=93506\n//\n// Returns nothing.\nfunction locationReplace(url) {\n  window.history.replaceState(null, \"\", pjax.state.url)\n  window.location.replace(url)\n}\n\n\nvar initialPop = true\nvar initialURL = window.location.href\nvar initialState = window.history.state\n\n// Initialize $.pjax.state if possible\n// Happens when reloading a page and coming forward from a different\n// session history.\nif (initialState && initialState.container) {\n  pjax.state = initialState\n}\n\n// Non-webkit browsers don't fire an initial popstate event\nif ('state' in window.history) {\n  initialPop = false\n}\n\n// popstate handler takes care of the back and forward buttons\n//\n// You probably shouldn't use pjax on pages with other pushState\n// stuff yet.\nfunction onPjaxPopstate(event) {\n\n  // Hitting back or forward should override any pending PJAX request.\n  if (!initialPop) {\n    abortXHR(pjax.xhr)\n  }\n\n  var previousState = pjax.state\n  var state = event.state\n  var direction\n\n  if (state && state.container) {\n    // When coming forward from a separate history session, will get an\n    // initial pop with a state we are already at. Skip reloading the current\n    // page.\n    if (initialPop && initialURL == state.url) return\n\n    if (previousState) {\n      // If popping back to the same state, just skip.\n      // Could be clicking back from hashchange rather than a pushState.\n      if (previousState.id === state.id) return\n\n      // Since state IDs always increase, we can deduce the navigation direction\n      direction = previousState.id < state.id ? 'forward' : 'back'\n    }\n\n    var cache = cacheMapping[state.id] || []\n    var containerSelector = cache[0] || state.container\n    var container = $(containerSelector), contents = cache[1]\n\n    if (container.length) {\n      if (previousState) {\n        // Cache current container before replacement and inform the\n        // cache which direction the history shifted.\n        cachePop(direction, previousState.id, [containerSelector, cloneContents(container)])\n      }\n\n      var popstateEvent = $.Event('pjax:popstate', {\n        state: state,\n        direction: direction\n      })\n      container.trigger(popstateEvent)\n\n      var options = {\n        id: state.id,\n        url: state.url,\n        container: containerSelector,\n        push: false,\n        fragment: state.fragment,\n        timeout: state.timeout,\n        scrollTo: false\n      }\n\n      if (contents) {\n        container.trigger('pjax:start', [null, options])\n\n        pjax.state = state\n        if (state.title) document.title = state.title\n        var beforeReplaceEvent = $.Event('pjax:beforeReplace', {\n          state: state,\n          previousState: previousState\n        })\n        container.trigger(beforeReplaceEvent, [contents, options])\n        container.html(contents)\n\n        container.trigger('pjax:end', [null, options])\n      } else {\n        pjax(options)\n      }\n\n      // Force reflow/relayout before the browser tries to restore the\n      // scroll position.\n      container[0].offsetHeight // eslint-disable-line no-unused-expressions\n    } else {\n      locationReplace(location.href)\n    }\n  }\n  initialPop = false\n}\n\n// Fallback version of main pjax function for browsers that don't\n// support pushState.\n//\n// Returns nothing since it retriggers a hard form submission.\nfunction fallbackPjax(options) {\n  var url = $.isFunction(options.url) ? options.url() : options.url,\n      method = options.type ? options.type.toUpperCase() : 'GET'\n\n  var form = $('<form>', {\n    method: method === 'GET' ? 'GET' : 'POST',\n    action: url,\n    style: 'display:none'\n  })\n\n  if (method !== 'GET' && method !== 'POST') {\n    form.append($('<input>', {\n      type: 'hidden',\n      name: '_method',\n      value: method.toLowerCase()\n    }))\n  }\n\n  var data = options.data\n  if (typeof data === 'string') {\n    $.each(data.split('&'), function(index, value) {\n      var pair = value.split('=')\n      form.append($('<input>', {type: 'hidden', name: pair[0], value: pair[1]}))\n    })\n  } else if ($.isArray(data)) {\n    $.each(data, function(index, value) {\n      form.append($('<input>', {type: 'hidden', name: value.name, value: value.value}))\n    })\n  } else if (typeof data === 'object') {\n    var key\n    for (key in data)\n      form.append($('<input>', {type: 'hidden', name: key, value: data[key]}))\n  }\n\n  $(document.body).append(form)\n  form.submit()\n}\n\n// Internal: Abort an XmlHttpRequest if it hasn't been completed,\n// also removing its event handlers.\nfunction abortXHR(xhr) {\n  if ( xhr && xhr.readyState < 4) {\n    xhr.onreadystatechange = $.noop\n    xhr.abort()\n  }\n}\n\n// Internal: Generate unique id for state object.\n//\n// Use a timestamp instead of a counter since ids should still be\n// unique across page loads.\n//\n// Returns Number.\nfunction uniqueId() {\n  return (new Date).getTime()\n}\n\nfunction cloneContents(container) {\n  var cloned = container.clone()\n  // Unmark script tags as already being eval'd so they can get executed again\n  // when restored from cache. HAXX: Uses jQuery internal method.\n  cloned.find('script').each(function(){\n    if (!this.src) $._data(this, 'globalEval', false)\n  })\n  return cloned.contents()\n}\n\n// Internal: Strip internal query params from parsed URL.\n//\n// Returns sanitized url.href String.\nfunction stripInternalParams(url) {\n  url.search = url.search.replace(/([?&])(_pjax|_)=[^&]*/g, '').replace(/^&/, '')\n  return url.href.replace(/\\?($|#)/, '$1')\n}\n\n// Internal: Parse URL components and returns a Locationish object.\n//\n// url - String URL\n//\n// Returns HTMLAnchorElement that acts like Location.\nfunction parseURL(url) {\n  var a = document.createElement('a')\n  a.href = url\n  return a\n}\n\n// Internal: Return the `href` component of given URL object with the hash\n// portion removed.\n//\n// location - Location or HTMLAnchorElement\n//\n// Returns String\nfunction stripHash(location) {\n  return location.href.replace(/#.*/, '')\n}\n\n// Internal: Build options Object for arguments.\n//\n// For convenience the first parameter can be either the container or\n// the options object.\n//\n// Examples\n//\n//   optionsFor('#container')\n//   // => {container: '#container'}\n//\n//   optionsFor('#container', {push: true})\n//   // => {container: '#container', push: true}\n//\n//   optionsFor({container: '#container', push: true})\n//   // => {container: '#container', push: true}\n//\n// Returns options Object.\nfunction optionsFor(container, options) {\n  if (container && options) {\n    options = $.extend({}, options)\n    options.container = container\n    return options\n  } else if ($.isPlainObject(container)) {\n    return container\n  } else {\n    return {container: container}\n  }\n}\n\n// Internal: Filter and find all elements matching the selector.\n//\n// Where $.fn.find only matches descendants, findAll will test all the\n// top level elements in the jQuery object as well.\n//\n// elems    - jQuery object of Elements\n// selector - String selector to match\n//\n// Returns a jQuery object.\nfunction findAll(elems, selector) {\n  return elems.filter(selector).add(elems.find(selector))\n}\n\nfunction parseHTML(html) {\n  return $.parseHTML(html, document, true)\n}\n\n// Internal: Extracts container and metadata from response.\n//\n// 1. Extracts X-PJAX-URL header if set\n// 2. Extracts inline <title> tags\n// 3. Builds response Element and extracts fragment if set\n//\n// data    - String response data\n// xhr     - XHR response\n// options - pjax options Object\n//\n// Returns an Object with url, title, and contents keys.\nfunction extractContainer(data, xhr, options) {\n  var obj = {}, fullDocument = /<html/i.test(data)\n\n  // Prefer X-PJAX-URL header if it was set, otherwise fallback to\n  // using the original requested url.\n  var serverUrl = xhr.getResponseHeader('X-PJAX-URL')\n  obj.url = serverUrl ? stripInternalParams(parseURL(serverUrl)) : options.requestUrl\n\n  var $head, $body\n  // Attempt to parse response html into elements\n  if (fullDocument) {\n    $body = $(parseHTML(data.match(/<body[^>]*>([\\s\\S.]*)<\\/body>/i)[0]))\n    var head = data.match(/<head[^>]*>([\\s\\S.]*)<\\/head>/i)\n    $head = head != null ? $(parseHTML(head[0])) : $body\n  } else {\n    $head = $body = $(parseHTML(data))\n  }\n\n  // If response data is empty, return fast\n  if ($body.length === 0)\n    return obj\n\n  // If there's a <title> tag in the header, use it as\n  // the page's title.\n  obj.title = findAll($head, 'title').last().text()\n\n  if (options.fragment) {\n    var $fragment = $body\n    // If they specified a fragment, look for it in the response\n    // and pull it out.\n    if (options.fragment !== 'body') {\n      $fragment = findAll($fragment, options.fragment).first()\n    }\n\n    if ($fragment.length) {\n      obj.contents = options.fragment === 'body' ? $fragment : $fragment.contents()\n\n      // If there's no title, look for data-title and title attributes\n      // on the fragment\n      if (!obj.title)\n        obj.title = $fragment.attr('title') || $fragment.data('title')\n    }\n\n  } else if (!fullDocument) {\n    obj.contents = $body\n  }\n\n  // Clean up any <title> tags\n  if (obj.contents) {\n    // Remove any parent title elements\n    obj.contents = obj.contents.not(function() { return $(this).is('title') })\n\n    // Then scrub any titles from their descendants\n    obj.contents.find('title').remove()\n\n    // Gather all script[src] elements\n    obj.scripts = findAll(obj.contents, 'script[src]').remove()\n    obj.contents = obj.contents.not(obj.scripts)\n  }\n\n  // Trim any whitespace off the title\n  if (obj.title) obj.title = $.trim(obj.title)\n\n  return obj\n}\n\n// Load an execute scripts using standard script request.\n//\n// Avoids jQuery's traditional $.getScript which does a XHR request and\n// globalEval.\n//\n// scripts - jQuery object of script Elements\n//\n// Returns nothing.\nfunction executeScriptTags(scripts) {\n  if (!scripts) return\n\n  var existingScripts = $('script[src]')\n\n  scripts.each(function() {\n    var src = this.src\n    var matchedScripts = existingScripts.filter(function() {\n      return this.src === src\n    })\n    if (matchedScripts.length) return\n\n    var script = document.createElement('script')\n    var type = $(this).attr('type')\n    if (type) script.type = type\n    script.src = $(this).attr('src')\n    document.head.appendChild(script)\n  })\n}\n\n// Internal: History DOM caching class.\nvar cacheMapping      = {}\nvar cacheForwardStack = []\nvar cacheBackStack    = []\n\n// Push previous state id and container contents into the history\n// cache. Should be called in conjunction with `pushState` to save the\n// previous container contents.\n//\n// id    - State ID Number\n// value - DOM Element to cache\n//\n// Returns nothing.\nfunction cachePush(id, value) {\n  cacheMapping[id] = value\n  cacheBackStack.push(id)\n\n  // Remove all entries in forward history stack after pushing a new page.\n  trimCacheStack(cacheForwardStack, 0)\n\n  // Trim back history stack to max cache length.\n  trimCacheStack(cacheBackStack, pjax.defaults.maxCacheLength)\n}\n\n// Shifts cache from directional history cache. Should be\n// called on `popstate` with the previous state id and container\n// contents.\n//\n// direction - \"forward\" or \"back\" String\n// id        - State ID Number\n// value     - DOM Element to cache\n//\n// Returns nothing.\nfunction cachePop(direction, id, value) {\n  var pushStack, popStack\n  cacheMapping[id] = value\n\n  if (direction === 'forward') {\n    pushStack = cacheBackStack\n    popStack  = cacheForwardStack\n  } else {\n    pushStack = cacheForwardStack\n    popStack  = cacheBackStack\n  }\n\n  pushStack.push(id)\n  id = popStack.pop()\n  if (id) delete cacheMapping[id]\n\n  // Trim whichever stack we just pushed to to max cache length.\n  trimCacheStack(pushStack, pjax.defaults.maxCacheLength)\n}\n\n// Trim a cache stack (either cacheBackStack or cacheForwardStack) to be no\n// longer than the specified length, deleting cached DOM elements as necessary.\n//\n// stack  - Array of state IDs\n// length - Maximum length to trim to\n//\n// Returns nothing.\nfunction trimCacheStack(stack, length) {\n  while (stack.length > length)\n    delete cacheMapping[stack.shift()]\n}\n\n// Public: Find version identifier for the initial page load.\n//\n// Returns String version or undefined.\nfunction findVersion() {\n  return $('meta').filter(function() {\n    var name = $(this).attr('http-equiv')\n    return name && name.toUpperCase() === 'X-PJAX-VERSION'\n  }).attr('content')\n}\n\n// Install pjax functions on $.pjax to enable pushState behavior.\n//\n// Does nothing if already enabled.\n//\n// Examples\n//\n//     $.pjax.enable()\n//\n// Returns nothing.\nfunction enable() {\n  $.fn.pjax = fnPjax\n  $.pjax = pjax\n  $.pjax.enable = $.noop\n  $.pjax.disable = disable\n  $.pjax.click = handleClick\n  $.pjax.submit = handleSubmit\n  $.pjax.reload = pjaxReload\n  $.pjax.defaults = {\n    timeout: 650,\n    push: true,\n    replace: false,\n    type: 'GET',\n    dataType: 'html',\n    scrollTo: 0,\n    maxCacheLength: 20,\n    version: findVersion\n  }\n  $(window).on('popstate.pjax', onPjaxPopstate)\n}\n\n// Disable pushState behavior.\n//\n// This is the case when a browser doesn't support pushState. It is\n// sometimes useful to disable pushState for debugging on a modern\n// browser.\n//\n// Examples\n//\n//     $.pjax.disable()\n//\n// Returns nothing.\nfunction disable() {\n  $.fn.pjax = function() { return this }\n  $.pjax = fallbackPjax\n  $.pjax.enable = enable\n  $.pjax.disable = $.noop\n  $.pjax.click = $.noop\n  $.pjax.submit = $.noop\n  $.pjax.reload = function() { window.location.reload() }\n\n  $(window).off('popstate.pjax', onPjaxPopstate)\n}\n\n\n// Add the state property to jQuery's event object so we can use it in\n// $(window).bind('popstate')\nif ($.event.props && $.inArray('state', $.event.props) < 0) {\n  $.event.props.push('state')\n} else if (!('state' in $.Event.prototype)) {\n  $.event.addProp('state')\n}\n\n// Is pjax supported by this browser?\n$.support.pjax =\n  window.history && window.history.pushState && window.history.replaceState &&\n  // pushState isn't reliable on iOS until 5.\n  !navigator.userAgent.match(/((iPod|iPhone|iPad).+\\bOS\\s+[1-4]\\D|WebApps\\/.+CFNetwork)/)\n\nif ($.support.pjax) {\n  enable()\n} else {\n  disable()\n}\n\n})(jQuery)\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./scripts/vendor/jquery.pjax.js\n ** module id = 4\n ** module chunks = 0\n **/"],"sourceRoot":""}